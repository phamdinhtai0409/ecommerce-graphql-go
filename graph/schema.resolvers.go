package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"time"

	"ecommerce-graphql-go/graph/model"
	"ecommerce-graphql-go/util"

	"github.com/99designs/gqlgen/graphql"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*model.Product, error) {
	product := &model.Product{
		ID:          fmt.Sprintf("%d", time.Now().UnixNano()),
		Name:        input.Name,
		Price:       input.Price,
		InStock:     input.InStock,
		Description: input.Description,
		Category:    input.Category,
	}

	r.Resolver.Data.CreateProduct(product)
	return &model.Product{
		ID:          product.ID,
		Name:        product.Name,
		Price:       product.Price,
		InStock:     product.InStock,
		Description: product.Description,
		Category:    product.Category,
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductInput) (*model.Product, error) {
	product := r.Resolver.Data.GetProduct(id)
	if product == nil {
		return nil, fmt.Errorf("product not found")
	}
	product.Name = input.Name
	product.Price = input.Price
	product.InStock = input.InStock
	product.Description = input.Description
	product.Category = input.Category

	r.Resolver.Data.UpdateProduct(product)

	return &model.Product{
		ID:          product.ID,
		Name:        product.Name,
		Price:       product.Price,
		InStock:     product.InStock,
		Description: product.Description,
		Category:    product.Category,
	}, nil
}

// PlaceOrder is the resolver for the placeOrder field.
func (r *mutationResolver) PlaceOrder(ctx context.Context, productIds []string) (*model.Order, error) {
	user := util.GetUserFromContext(ctx)

	var products []*model.Product
	var total float64
	for _, id := range productIds {
		product := r.Resolver.Data.GetProduct(id)
		if product == nil {
			return nil, fmt.Errorf("product not found: %s", id)
		}
		if product.InStock <= 0 {
			return nil, fmt.Errorf("product out of stock: %s", id)
		}
		products = append(products, product)
		total += product.Price
	}

	order := &model.Order{
		ID:        fmt.Sprintf("%d", time.Now().UnixNano()),
		Products:  products,
		Total:     total,
		Status:    "PENDING",
		User:      user,
		CreatedAt: time.Now().Format(time.RFC3339),
	}
	r.Resolver.Data.CreateOrder(order)
	return order, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, limit *int32, offset *int32, category *string) ([]*model.Product, error) {
	if limit == nil {
		l := int32(10)
		limit = &l
	}
	if offset == nil {
		o := int32(0)
		offset = &o
	}
	cat := ""
	if category != nil {
		cat = *category
	}

	products := r.Resolver.Data.GetProducts(*limit, *offset, cat)
	return products, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	product := r.Resolver.Data.GetProduct(id)
	if product == nil {
		return nil, nil
	}

	return &model.Product{
		ID:          product.ID,
		Name:        product.Name,
		Price:       product.Price,
		InStock:     product.InStock,
		Description: product.Description,
		Category:    product.Category,
	}, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	user := util.GetUserFromContext(ctx)
	orders := r.Resolver.Data.GetOrders(user.ID)
	result := make([]*model.Order, len(orders))

	for i, order := range orders {
		result[i] = &model.Order{
			ID:        order.ID,
			Products:  order.Products,
			Total:     order.Total,
			Status:    order.Status,
			User:      &model.User{ID: order.User.ID, Name: order.User.Name, Email: order.User.Email},
			CreatedAt: order.CreatedAt,
		}
	}
	return result, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	user := util.GetUserFromContext(ctx)
	order := r.Resolver.Data.GetOrder(id, user.ID)
	if order == nil {
		return nil, nil
	}

	return &model.Order{
		ID:        order.ID,
		Products:  order.Products,
		Total:     order.Total,
		Status:    order.Status,
		User:      &model.User{ID: order.User.ID, Name: order.User.Name, Email: order.User.Email},
		CreatedAt: order.CreatedAt,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func HasRoleDirective(ctx context.Context, obj interface{}, next graphql.Resolver, role model.Role) (interface{}, error) {
	user := util.GetUserFromContext(ctx)
	if user == nil || user.Role != role {
		return nil, fmt.Errorf("access denied: requires role %s", role)
	}
	return next(ctx)
}
